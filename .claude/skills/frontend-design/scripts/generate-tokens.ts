#!/usr/bin/env -S deno run --allow-read --allow-write

/**
 * generate-tokens.ts - Design Token Generator
 *
 * Generates comprehensive design token files in multiple formats
 * from a JSON specification.
 */

import { parseArgs } from "jsr:@std/cli@1.0.9/parse-args";
import { resolve, join } from "jsr:@std/path@1.0.8";
import { ensureDir } from "jsr:@std/fs@1.0.8/ensure-dir";

// === Constants ===
const VERSION = "1.0.0";
const SCRIPT_NAME = "generate-tokens";

type OutputFormat = "css" | "scss" | "json" | "js" | "ts" | "tailwind" | "style-dictionary";

// === Types ===
export interface TokenSpec {
  name: string;
  description?: string;
  tokens: {
    color?: Record<string, string | Record<string, string>>;
    spacing?: Record<string, string>;
    typography?: {
      fontFamilies?: Record<string, string>;
      fontSizes?: Record<string, string>;
      fontWeights?: Record<string, number>;
      lineHeights?: Record<string, string>;
      letterSpacing?: Record<string, string>;
    };
    shadow?: Record<string, string>;
    border?: {
      radius?: Record<string, string>;
      width?: Record<string, string>;
    };
    animation?: {
      duration?: Record<string, string>;
      easing?: Record<string, string>;
    };
    zIndex?: Record<string, number>;
  };
  outputFormats: OutputFormat[];
}

interface GenerateOptions {
  specFile: string;
  outputDir: string;
}

// === Token Flattening ===

function flattenTokens(
  obj: Record<string, unknown>,
  prefix = ""
): Record<string, string | number> {
  const result: Record<string, string | number> = {};

  for (const [key, value] of Object.entries(obj)) {
    const newKey = prefix ? `${prefix}-${key}` : key;

    if (typeof value === "object" && value !== null && !Array.isArray(value)) {
      Object.assign(result, flattenTokens(value as Record<string, unknown>, newKey));
    } else if (typeof value === "string" || typeof value === "number") {
      result[newKey] = value;
    }
  }

  return result;
}

// === Format Generators ===

function generateCSS(spec: TokenSpec): string {
  const lines: string[] = [
    `/* ${spec.name} Design Tokens */`,
    `/* ${spec.description || "Generated by generate-tokens"} */`,
    "",
    ":root {",
  ];

  const allTokens = flattenTokens(spec.tokens);

  // Group by category
  const categories = new Map<string, Record<string, string | number>>();

  for (const [key, value] of Object.entries(allTokens)) {
    const category = key.split("-")[0];
    if (!categories.has(category)) {
      categories.set(category, {});
    }
    categories.get(category)![key] = value;
  }

  for (const [category, tokens] of categories) {
    lines.push(`  /* ${category} */`);
    for (const [key, value] of Object.entries(tokens)) {
      lines.push(`  --${key}: ${value};`);
    }
    lines.push("");
  }

  lines.push("}");
  return lines.join("\n");
}

function generateSCSS(spec: TokenSpec): string {
  const lines: string[] = [
    `// ${spec.name} Design Tokens`,
    `// ${spec.description || "Generated by generate-tokens"}`,
    "",
  ];

  const allTokens = flattenTokens(spec.tokens);

  // Group by category
  const categories = new Map<string, Record<string, string | number>>();

  for (const [key, value] of Object.entries(allTokens)) {
    const category = key.split("-")[0];
    if (!categories.has(category)) {
      categories.set(category, {});
    }
    categories.get(category)![key] = value;
  }

  for (const [category, tokens] of categories) {
    lines.push(`// ${category}`);
    for (const [key, value] of Object.entries(tokens)) {
      const scssKey = key.replace(/-/g, "_");
      lines.push(`$${scssKey}: ${value};`);
    }
    lines.push("");
  }

  // Generate maps
  lines.push("// Token Maps");
  for (const [category, tokens] of categories) {
    const mapName = category.replace(/-/g, "_");
    lines.push(`$${mapName}_tokens: (`);
    for (const [key, value] of Object.entries(tokens)) {
      const shortKey = key.replace(`${category}-`, "");
      lines.push(`  '${shortKey}': ${value},`);
    }
    lines.push(");");
    lines.push("");
  }

  return lines.join("\n");
}

function generateJSON(spec: TokenSpec): string {
  const output = {
    name: spec.name,
    description: spec.description,
    tokens: spec.tokens,
  };
  return JSON.stringify(output, null, 2);
}

function generateJS(spec: TokenSpec): string {
  const lines: string[] = [
    `/**`,
    ` * ${spec.name} Design Tokens`,
    ` * ${spec.description || "Generated by generate-tokens"}`,
    ` */`,
    "",
    "export const tokens = " + JSON.stringify(spec.tokens, null, 2) + ";",
    "",
    "// Flattened tokens for direct access",
    "export const flatTokens = " + JSON.stringify(flattenTokens(spec.tokens), null, 2) + ";",
    "",
    "export default tokens;",
  ];

  return lines.join("\n");
}

function generateTS(spec: TokenSpec): string {
  const lines: string[] = [
    `/**`,
    ` * ${spec.name} Design Tokens`,
    ` * ${spec.description || "Generated by generate-tokens"}`,
    ` */`,
    "",
  ];

  // Generate type definitions
  lines.push("export interface DesignTokens {");

  if (spec.tokens.color) {
    lines.push("  color: {");
    for (const [key, value] of Object.entries(spec.tokens.color)) {
      if (typeof value === "string") {
        lines.push(`    ${key}: string;`);
      } else {
        lines.push(`    ${key}: Record<string, string>;`);
      }
    }
    lines.push("  };");
  }

  if (spec.tokens.spacing) {
    lines.push("  spacing: Record<string, string>;");
  }

  if (spec.tokens.typography) {
    lines.push("  typography: {");
    if (spec.tokens.typography.fontFamilies) {
      lines.push("    fontFamilies: Record<string, string>;");
    }
    if (spec.tokens.typography.fontSizes) {
      lines.push("    fontSizes: Record<string, string>;");
    }
    if (spec.tokens.typography.fontWeights) {
      lines.push("    fontWeights: Record<string, number>;");
    }
    if (spec.tokens.typography.lineHeights) {
      lines.push("    lineHeights: Record<string, string>;");
    }
    if (spec.tokens.typography.letterSpacing) {
      lines.push("    letterSpacing: Record<string, string>;");
    }
    lines.push("  };");
  }

  if (spec.tokens.shadow) {
    lines.push("  shadow: Record<string, string>;");
  }

  if (spec.tokens.border) {
    lines.push("  border: {");
    if (spec.tokens.border.radius) {
      lines.push("    radius: Record<string, string>;");
    }
    if (spec.tokens.border.width) {
      lines.push("    width: Record<string, string>;");
    }
    lines.push("  };");
  }

  if (spec.tokens.animation) {
    lines.push("  animation: {");
    if (spec.tokens.animation.duration) {
      lines.push("    duration: Record<string, string>;");
    }
    if (spec.tokens.animation.easing) {
      lines.push("    easing: Record<string, string>;");
    }
    lines.push("  };");
  }

  if (spec.tokens.zIndex) {
    lines.push("  zIndex: Record<string, number>;");
  }

  lines.push("}");
  lines.push("");

  // Generate the token object
  lines.push("export const tokens: DesignTokens = " + JSON.stringify(spec.tokens, null, 2) + " as const;");
  lines.push("");

  // Generate flattened tokens with type
  lines.push("export type FlatToken = string | number;");
  lines.push("export const flatTokens: Record<string, FlatToken> = " + JSON.stringify(flattenTokens(spec.tokens), null, 2) + ";");
  lines.push("");
  lines.push("export default tokens;");

  return lines.join("\n");
}

function generateTailwind(spec: TokenSpec): string {
  const config: Record<string, unknown> = {};

  if (spec.tokens.color) {
    config.colors = spec.tokens.color;
  }

  if (spec.tokens.spacing) {
    config.spacing = spec.tokens.spacing;
  }

  if (spec.tokens.typography) {
    if (spec.tokens.typography.fontFamilies) {
      config.fontFamily = {};
      for (const [key, value] of Object.entries(spec.tokens.typography.fontFamilies)) {
        (config.fontFamily as Record<string, string[]>)[key] = [value];
      }
    }
    if (spec.tokens.typography.fontSizes) {
      config.fontSize = spec.tokens.typography.fontSizes;
    }
    if (spec.tokens.typography.fontWeights) {
      config.fontWeight = spec.tokens.typography.fontWeights;
    }
    if (spec.tokens.typography.lineHeights) {
      config.lineHeight = spec.tokens.typography.lineHeights;
    }
    if (spec.tokens.typography.letterSpacing) {
      config.letterSpacing = spec.tokens.typography.letterSpacing;
    }
  }

  if (spec.tokens.shadow) {
    config.boxShadow = spec.tokens.shadow;
  }

  if (spec.tokens.border) {
    if (spec.tokens.border.radius) {
      config.borderRadius = spec.tokens.border.radius;
    }
    if (spec.tokens.border.width) {
      config.borderWidth = spec.tokens.border.width;
    }
  }

  if (spec.tokens.animation) {
    if (spec.tokens.animation.duration) {
      config.transitionDuration = spec.tokens.animation.duration;
    }
    if (spec.tokens.animation.easing) {
      config.transitionTimingFunction = spec.tokens.animation.easing;
    }
  }

  if (spec.tokens.zIndex) {
    config.zIndex = spec.tokens.zIndex;
  }

  return `/**
 * ${spec.name} - Tailwind Config
 * ${spec.description || "Generated by generate-tokens"}
 *
 * Add to tailwind.config.js:
 * const tokens = require('./tokens.tailwind.js');
 * module.exports = { theme: { extend: tokens } };
 */

module.exports = ${JSON.stringify(config, null, 2).replace(/"([^"]+)":/g, "$1:")};
`;
}

function generateStyleDictionary(spec: TokenSpec): string {
  const sdTokens: Record<string, unknown> = {};

  function convertToSD(obj: unknown, category: string): unknown {
    if (typeof obj === "string" || typeof obj === "number") {
      return { value: obj };
    }
    if (typeof obj === "object" && obj !== null) {
      const result: Record<string, unknown> = {};
      for (const [key, value] of Object.entries(obj)) {
        result[key] = convertToSD(value, category);
      }
      return result;
    }
    return obj;
  }

  for (const [category, tokens] of Object.entries(spec.tokens)) {
    sdTokens[category] = convertToSD(tokens, category);
  }

  return JSON.stringify(sdTokens, null, 2);
}

// === File Extension Mapping ===

function getFileExtension(format: OutputFormat): string {
  switch (format) {
    case "css":
      return "css";
    case "scss":
      return "scss";
    case "json":
    case "style-dictionary":
      return "json";
    case "js":
      return "js";
    case "ts":
      return "ts";
    case "tailwind":
      return "tailwind.js";
    default:
      return "txt";
  }
}

function getFileName(name: string, format: OutputFormat): string {
  const baseName = name.toLowerCase().replace(/\s+/g, "-");
  const ext = getFileExtension(format);

  if (format === "style-dictionary") {
    return `${baseName}.tokens.json`;
  }

  return `${baseName}.${ext}`;
}

// === Core Generation Function ===

export async function generateTokens(options: GenerateOptions): Promise<Map<string, string>> {
  const specPath = resolve(options.specFile);
  const specContent = await Deno.readTextFile(specPath);
  const spec: TokenSpec = JSON.parse(specContent);

  if (!spec.name) {
    throw new Error("Token specification must include a 'name' field");
  }

  if (!spec.tokens) {
    throw new Error("Token specification must include a 'tokens' field");
  }

  if (!spec.outputFormats || spec.outputFormats.length === 0) {
    throw new Error("Token specification must include at least one output format");
  }

  const outputs = new Map<string, string>();

  for (const format of spec.outputFormats) {
    let content: string;

    switch (format) {
      case "css":
        content = generateCSS(spec);
        break;
      case "scss":
        content = generateSCSS(spec);
        break;
      case "json":
        content = generateJSON(spec);
        break;
      case "js":
        content = generateJS(spec);
        break;
      case "ts":
        content = generateTS(spec);
        break;
      case "tailwind":
        content = generateTailwind(spec);
        break;
      case "style-dictionary":
        content = generateStyleDictionary(spec);
        break;
      default:
        console.warn(`Unknown format: ${format}, skipping`);
        continue;
    }

    const fileName = getFileName(spec.name, format);
    outputs.set(fileName, content);
  }

  return outputs;
}

// === Help Text ===

function printHelp(): void {
  console.log(`
${SCRIPT_NAME} v${VERSION} - Design Token Generator

Generates comprehensive design token files in multiple formats
from a JSON specification.

Usage:
  deno run --allow-read --allow-write scripts/${SCRIPT_NAME}.ts <spec> <output-dir>

Arguments:
  <spec>               JSON specification file (see assets/token-schema.json)
  <output-dir>         Directory for output files

Options:
  -h, --help           Show this help message
  -v, --version        Show version

Supported Output Formats (specified in spec file):
  css              CSS custom properties
  scss             SCSS variables and maps
  json             Raw JSON
  js               JavaScript module
  ts               TypeScript module with types
  tailwind         Tailwind config extension
  style-dictionary Style Dictionary format

Example Specification:
  {
    "name": "my-design-system",
    "tokens": {
      "color": { "primary": "#2563eb" },
      "spacing": { "sm": "0.5rem", "md": "1rem" }
    },
    "outputFormats": ["css", "scss", "tailwind", "ts"]
  }

Examples:
  # Generate from specification
  deno run --allow-read --allow-write scripts/${SCRIPT_NAME}.ts design-tokens.json ./tokens/

  # Using the schema for validation
  See assets/token-schema.json for full specification format
`);
}

// === Main CLI Handler ===

async function main(args: string[]): Promise<void> {
  const parsed = parseArgs(args, {
    boolean: ["help", "version"],
    alias: { h: "help", v: "version" },
  });

  if (parsed.help) {
    printHelp();
    Deno.exit(0);
  }

  if (parsed.version) {
    console.log(`${SCRIPT_NAME} v${VERSION}`);
    Deno.exit(0);
  }

  const specFile = parsed._[0] as string;
  const outputDir = parsed._[1] as string;

  if (!specFile) {
    console.error("Error: Specification file required");
    console.error("Use --help for usage information");
    Deno.exit(1);
  }

  if (!outputDir) {
    console.error("Error: Output directory required");
    console.error("Use --help for usage information");
    Deno.exit(1);
  }

  const options: GenerateOptions = {
    specFile,
    outputDir,
  };

  try {
    const outputs = await generateTokens(options);
    const outPath = resolve(outputDir);

    await ensureDir(outPath);

    for (const [fileName, content] of outputs) {
      const filePath = join(outPath, fileName);
      await Deno.writeTextFile(filePath, content);
      console.log(`Generated: ${filePath}`);
    }

    console.log(`\nSuccessfully generated ${outputs.size} token files`);
  } catch (error) {
    console.error(`Error: ${(error as Error).message}`);
    Deno.exit(1);
  }
}

// === Entry Point ===

if (import.meta.main) {
  main(Deno.args);
}
